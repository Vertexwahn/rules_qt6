
from aqt.archives import QtArchives, QtPackage
from aqt.installer import Cli, InstallArgParser
from aqt.metadata import Version
from aqt.helper import get_hash, Settings, retry_on_bad_connection
from aqt.exceptions import CliInputError

BZL_CONFIG_HEADER = """## This file was generated by bqtinstaller.py (bazel qt installer)
# To update run: bazel run {}
#
"""

class BazelCli(Cli):
    # Need to provide where to output the qt_modules.bzl file.
    def _set_install_qt_parser(self, install_qt_parser, *args, **kwargs):
        super()._set_install_qt_parser(install_qt_parser, *args, **kwargs)
        install_qt_parser.add_argument(
            "--bzl-config-out",
            help="Path to write the bzl config file",
            required=True,
        )
        install_qt_parser.add_argument(
            "--bzl-update-target",
            help="Bazel target to update the bzl config file",
            required=True,
        )

    def run_install_qt(self, args: InstallArgParser):
        """Run install subcommand"""
        self.show_aqt_version()
        if args.is_legacy:
            self._warn_on_deprecated_command("install", "install-qt")

        target: str = args.target
        os_name: str = args.host
        qt_version_or_spec: str = getattr(args, "qt_version", getattr(args, "qt_version_spec", ""))
        arch: str = self._set_arch(args.arch, os_name, target, qt_version_or_spec)
        keep: bool = args.keep or Settings.always_keep_archives
        archive_dest: Optional[str] = args.archive_dest
        output_dir = args.outputdir

        if output_dir is None:
            base_dir = os.getcwd()
        else:
            base_dir = output_dir

        if args.timeout is not None:
            timeout = (args.timeout, args.timeout)
        else:
            timeout = (Settings.connection_timeout, Settings.response_timeout)

        start_time = time.perf_counter()
        modules = args.modules
        sevenzip = self._set_sevenzip(args.external)

        if args.base is not None:
            if not self._check_mirror(args.base):
                raise CliInputError(
                    "The `--base` option requires a url where the path "
                    "`online/qtsdkrepository` exists.",
                    should_show_help=True,
                )
            base = args.base
        else:
            base = Settings.baseurl

        if hasattr(args, "qt_version_spec"):
            qt_version: str = str(Cli._determine_qt_version(args.qt_version_spec, os_name, target, arch, base_url=base))
        else:
            qt_version = args.qt_version
            Cli._validate_version_str(qt_version)

        archives = args.archives
        if args.noarchives:
            if modules is None:
                raise CliInputError("When `--noarchives` is set, the `--modules` option is mandatory.")
            if archives is not None:
                raise CliInputError("Options `--archives` and `--noarchives` are mutually exclusive.")
        else:
            if modules is not None and archives is not None:
                archives.extend(modules)

        nopatch = args.noarchives or (archives is not None and "qtbase" not in archives)  # type: bool
        should_autoinstall: bool = args.autodesktop
        _version = Version(qt_version)
        base_path = Path(base_dir)

        expect_desktop_archdir, autodesk_arch = self._get_autodesktop_dir_and_arch(
            should_autoinstall, os_name, target, base_path, _version, arch
        )

        def get_auto_desktop_archives() -> List[QtPackage]:
            def to_archives(baseurl: str) -> QtArchives:
                return QtArchives(os_name, "desktop", qt_version, cast(str, autodesk_arch), base=baseurl, timeout=timeout)

            if autodesk_arch is not None:
                return cast(QtArchives, retry_on_bad_connection(to_archives, base)).archives
            else:
                return []

        auto_desktop_archives: List[QtPackage] = get_auto_desktop_archives()

        if not self._check_qt_arg_versions(qt_version):
            self.logger.warning(self._warning_unknown_qt_version(qt_version))
        if not self._check_qt_arg_combination(qt_version, os_name, target, arch):
            self.logger.warning(self._warning_unknown_target_arch_combo([os_name, target, arch]))

        all_extra = True if modules is not None and "all" in modules else False
        if not all_extra:
            unexpected_modules = self._select_unexpected_modules(qt_version, modules)
            if unexpected_modules:
                self.logger.warning(self._warning_unexpected_modules(unexpected_modules))

        qt_archives: QtArchives = retry_on_bad_connection(
            lambda base_url: QtArchives(
                os_name,
                target,
                qt_version,
                arch,
                base=base_url,
                subarchives=archives,
                modules=modules,
                all_extra=all_extra,
                is_include_base_package=not args.noarchives,
                timeout=timeout,
            ),
            base,
        )

        qt_archives.archives.extend(auto_desktop_archives)
        target_config = qt_archives.get_target_config()

        download_info_dict = {}
        for archive in qt_archives.get_packages():
            # Skip archives that are only for debug symbols
            if "debug_info" not in archive.archive_path:
                url = os.path.join(archive.base_url, archive.archive_path)
                sha256 = get_hash(archive.archive_path, "sha256", 60).hex()
                download_info_dict[archive.name] = {}
                download_info_dict[archive.name]["url"] = url
                download_info_dict[archive.name]["sha256"] = sha256
                print(f"stored: {archive.name}")

        # write the download info into a file
        bzl_download_info_file = os.path.join(os.environ.get("BUILD_WORKSPACE_DIRECTORY", "."), args.bzl_config_out)
        with open(bzl_download_info_file, "w") as file:
            file.write(BZL_CONFIG_HEADER.format(args.bzl_update_target))
            file.write("QT_MODULES = ")
            file.write(json.dumps(download_info_dict, indent=4))

        self.logger.info("Finished installation")
        self.logger.info("Time elapsed: {time:.8f} second".format(time=time.perf_counter() - start_time))


def main():
    cli = BazelCli()
    return cli.run()


if __name__ == "__main__":
    main()
